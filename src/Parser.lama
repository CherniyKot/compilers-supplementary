-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun toBinop(l, op, r){
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),

-- expr = Var   (string)             |
--        Const (int)                |
--        Binop (string, expr, expr)
    exp = memo $ eta expr({
      [Left, {
        [s("!!"), toBinop]
        }],

      [Left, {
        [s("&&"), toBinop]
        }],
      
      [Nona, {
        [s(">") | s("<") | s(">=") | s("<=") | s("==") | s("!="), toBinop]
        }],

      [Left, {
        [s("+") | s("-"), toBinop]
        }],
        
      [Left, {
        [s("*") | s("/") | s("%"), toBinop]
        }]
      }, primary);
                            -- eta syntax(primary                                 |
                            -- l=exp s["+"] r=exp {Binop("+", l, r)}   |
                            -- l=exp s["-"] r=exp {Binop("-", l, r)}   |
                            -- l=exp s["*"] r=exp {Binop("*", l, r)}   |
                            -- l=exp s["/"] r=exp {Binop("/", l, r)}   |
                            -- l=exp s["%"] r=exp {Binop("%", l, r)}   |

                            -- l=exp s[">"] r=exp {Binop(">", l, r)}   |
                            -- l=exp s["<"] r=exp {Binop("<", l, r)}   |
                            -- l=exp s[">="] r=exp {Binop(">=", l, r)} |
                            -- l=exp s["<="] r=exp {Binop("<=", l, r)} |
                            -- l=exp s["=="] r=exp {Binop("==", l, r)} |
                            -- l=exp s["!="] r=exp {Binop("!=", l, r)} |

                            -- l=exp s["&&"] r=exp {Binop("&&", l, r)} |
                            -- l=exp s["!!"] r=exp {Binop("!!", l, r)} 
                            -- );

-- stmt = Assn   (string, expr)     |
--        Seq    (stmt, stmt)       | l=stmt s[";"] r=stmt {Seq(l, r)}
--        Skip                      |
--        Read   (string)           |
--        Write  (expr)             |
var stmt = memo $ eta syntax (x=lident s[":="] y=exp {Assn(x, y)}  |
                              kSkip {Skip}                        |
                              kRead x=inbr[s("("), lident, s(")")]  {Read (x)}          |
                              kWrite x=inbr[s("("), exp, s(")")] {Write (x)});
   

-- Public top-level parser
public parse = memo $ eta expr({[Left, {[s(";"), fun(l, op, r){ Seq(l, r) }]}]}, stmt);
             
