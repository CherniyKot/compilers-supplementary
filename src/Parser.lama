-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun toBinop(l, op, r){
  Binop(op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),

-- expr = Var   (string)             |
--        Const (int)                |
--        Binop (string, expr, expr)
    exp = memo $ eta expr({
      [Left, {
        [s("!!"), toBinop]
        }],

      [Left, {
        [s("&&"), toBinop]
        }],
      
      [Nona, {
        [s(">") | s("<") | s(">=") | s("<=") | s("==") | s("!="), toBinop]
        }],

      [Left, {
        [s("+") | s("-"), toBinop]
        }],
        
      [Left, {
        [s("*") | s("/") | s("%"), toBinop]
        }]
      }, primary);

-- stmt = Assn    (string, expr)     |
--        Seq     (stmt, stmt)       |
--        Skip                       |
--        Read    (string)           |
--        Write   (expr)             |
--        If      (expr, stmt, stmt) |
--        While   (expr, stmt)       |
--        DoWhile (stmt, expr)
var stmt = memo $ eta syntax (x=lident s[":="] y=exp {Assn(x, y)}                       |
                              kSkip {Skip}                                              |
                              kRead x=inbr[s("("), lident, s(")")]  {Read (x)}          |
                              kWrite x=inbr[s("("), exp, s(")")] {Write (x)}            |

                              kIf cond=exp kThen
                                trueStmts=stmts
                              branches=(-kElif elifCond=exp -kThen elifStmt=stmts)*
                              falseStmts=(-kElse stmts)?
                              kFi {parseElifs([cond, trueStmts, case falseStmts of Some(x) -> x | None -> Skip esac], branches)} |

                              kWhile cond=exp kDo what=stmts kOd {While(cond, what)}    |
                              kDo what=stmts kWhile cond=exp kOd {DoWhile(what, cond)}  |

                              kFor start=stmt s[","] cond=exp s[","] end=stmt
                              kDo
                                what=stmts
                              kOd {Seq(start, While(cond, Seq(what, end)))}
                              ),
    stmts = memo $ eta expr({[Left, {[s(";"), fun(l, op, r){ Seq(l, r) }]}]}, stmt);
   
fun parseElifs([cond, trueStmts, falseStmts], branches){
  case branches of
    {} -> If(cond, trueStmts, falseStmts) |
    [elifCond, elifStmts]:rest -> If(cond, trueStmts, parseElifs([elifCond, elifStmts, falseStmts], rest))
  esac 
}


-- Public top-level parser
public parse = stmts;
             
